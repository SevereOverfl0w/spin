= Spin
:toc: macro
:toclevels: 4

_Far more web_ for _much less code_.

Spin is a small, https://github.com/ring-clojure/ring/blob/2.0/SPEC-2.md[Ring
2.0]-compatible, Clojure library that helps you write HTTP endpoints that
actually conform to HTTP.

toc::[]

== Introduction

Since the earliest web servers, dynamic behaviour in web servers has been built
on the https://www.w3.org/CGI/[CGI: Common Gateway Interface]. CGI itself has
been consigned to history but the model of web development that it inspired is
still by far the dominant model used by developers of dynamic websites and web
APIs.

In CGI, a web-server captures information about a web request (such as the
request method, path, remote address, query-string, etc.) and calls a sends it
to an external program, script, plugin or in-process function, that generates
the response on behalf of the web server.

As web-servers have evolved, virtually every web library and framework has
inherited this minimalist design: from Java's 'servlets' and Ruby's
https://www.rubyguides.com/2018/09/rack-middleware/[Rack] and PHP to Node.js
Express, Erlang's https://www.phoenixframework.org/[Phoenix], Clojure's
https://github.com/ring-clojure/ring[Ring] and hundreds more.

== Problem Statement

The problem at the heart of CGI, and everything based on it, is that it is an
interface based on a web _request_ rather than a web _resource_. It was designed
to attach basic scripts to web servers, not to build the web itself.

The web is built on the HTTP protocol, which governs how browsers, web-servers,
proxies and other participants communicate. What does HTTP provide? It's right
there in just the second paragraph:

[quote,RFC 7231 - Section 1]
____
HTTP provides a uniform interface for interacting with a _resource_
____

The problem with CGI-based web libraries is that CGI is too low-level. It asks
too much of developers who have to recreate this 'resource' abstraction in every
handler they write. Of course this results in HTTP services that are half-baked,
half-implemented and non-comformant with HTTP. This makes the web poorer, more
brittle, *less inter-operable*, *less flexible*, *more expensive to create and
maintain*.

== Proposed Solution

This project defines a new _resource-oriented_ interface to replace CGI.

It also provides an adapter that converts the CGI-based request-oriented
interface of Java/Clojure web servers to this new resource-oriented interface.

You provide the resource (in the form of data and functions). In exchange, you
get a Ring 2.0 handler that fully conforms with HTTP.

Spin's goal is to assist developers in implementing RFCs 7231-7235, and possibly
other RFCs, as faithfully as possible.

Spin is a Clojure project because that language provides a very fast design
iteration cycle. But it's hoped that once Spin's design stabilises it can be
copied by others, just as CGI was.

== Status

Spin is still under active development and is ALPHA status, meaning that the API
should be considered unstable and likely to change.

It is planned that Spin will be agnostic as to whether you are using Ring's sync
(1-arity) of async (3-arity) forms and will support both.

== Documentation

Spin is based on Clojure maps, with namespaced keywords. Functions take maps
and, usually, return other maps.

For example, you create a Ring handler with `juxt.spin.alpha/handler` that takes a single
map argument.

.Hello World!
====
To return the message "Hello World!" from a GET request:

[source,clojure]
----
(require '[juxt.spin.alpha :as spin])

(def hello
  (spin/handler
    {::spin/resource <1>
      {::spin/representation <2>
        {::spin/content "Hello World!\n"}}}))

(hello req)
=>
{:ring.response/status 200
 :ring.response/headers
  {"content-length" "13"
   "date" "Thu, 26 Nov 2020 16:53:14 GMT"}
 :ring.response/body "Hello World!\n"}
----
<1> See <<resource>>
<2> See <<representation>>
====

This map contains the following entries, which are namespaced in the
`juxt.spin.alpha` namespace.

=== Handler map entries

Whether you should choose a resource or a resource locator depends on your
application. If you are using a router
(https://github.com/weavejester/compojure[Compojure],
https://github.com/juxt/bidi[bidi], https://github.com/metosin/reitit[reitit],
etc.), you might route directly to the target resource. This also makes sense
for simple demos.

However, the benefit of using `locate-resource!` is that you can have one initial
context defined with all your application-wide (or context-wide) configuration
and policies.

requirements:: The handler map should contain at least one of `resource` and
`locate-resource!`.

[[resource]]
==== `resource`

A map describing the target resource.

If `resource` is provided, then it is used regardless of whether
`locate-resource!` is provided also. See `locate-resource!`.

TIP: Many web programmers write their routes directly into their code. You can
do this, but you should consider whether your routes belong elsewhere, such as
in config or a database. This might allow your web application to be more
dynamic and flexible in the future. A more dynamic approach is to use
`locate-resource!`.

==== `locate-resource!`

A function that takes a request map as an argument, and returns the target
resource (in the form of a Clojure map).

A resource is always deemed to exist. Return an empty map (`{}`) if there are no
current representations for the resource. Don't return nil!

The `locate-resource!` function can use the `respond!` entry in the request map
in order to respond directly. This effectively returns a nil, which indicates a
response is made directly. Therefore, it is important never to return nil from
`locate-resource!`.

If `locate-resource!` is not provided in the initial context, the resource
defaults to an empty map.

==== `error-representation`

A function that takes the inital context as an argument and returns a map
corresponding to the selected representation's metadata of the error.

=== Resource entries

A resource is a Clojure map that can contain any entries that assist in the
processing of a request.

Keywords with namespaces that are prefixed with `juxt.spin` are *reserved*,
including `juxt.spin.alpha`. These reserved entries, which are described in this
section, form the 'interface' for interacting with the resource.

==== `validate-request!`

A function that takes a context argument and returns it, or (optionally) a
modified version of it, if the request is valid.

The resource can be found in the `:resource` entry of the context.

If the request is malformed or invalid in some way, the function MUST respond
directly using the function in the `:respond!` entry of the context.

When responding, the function SHOULD use the value in the `:response` entry of
the context (although it is free to modify it as necessary).

.Responding with a 400 (Bad Request)
====

Say you have a resource that requires a query parameter to be present. Requests
without this query parameter are considered invalid and should result in a 400
response.

[source,clojure]
----
{::spin/resource
  {::spin/representation {}
   ::spin/validate-request!
   (fn [{::spin/keys [request respond! response] :as ctx}]
     (if (:ring.request/query request)
       ctx
       ;; No query string, bad request!
       (respond!
        (assoc
         response
         :ring.response/status 400
         :ring.response/body "Bad request!"))))}}
----
====

The `validate-request!` is also the place to authenticate the request and ensure
it is authorized to interact with the resource.

.Authorizing a request
[source,clojure]
====

In this example, we use the `validate-request!` function in conjunction with
some custom data in our resource to implement restrictions to a resource.

First, we'll need to authenticate the request. We'll assign each request a
single role.

WARNING: We'll use an extremely silly authentication scheme (called `Terrible`)
FOR THE PURPOSES OF THIS EXPLANATION ONLY. Don't copy this!

Then we'll check the role provides the entitlement to access the resource using
the method in the requested. We could use any arbitary authorization logic here
instead.

The `validate-request!` function first determines the role by authenticating the
request. Normally, you wouldn't automatically trust the user agent like this,
instead, you'd add some way of verifying the trust, e.g. JWT signatures, a
database lookup.

[source,clojure]
----
{::spin/resource
   {:roles {:superuser #{:get :head :put}
            :manager #{:get :head}} <1>
    ::spin/representation {::spin/content "Secret stuff!"}
    ::spin/validate-request!
    (fn [{::spin/keys [request respond! response resource] :as ctx}]
      (if-let [role <2>
               (case (get-in request
                             [:ring.request/headers "authorization"])

                 "Terrible let-me-in;role=superuser"
                 :superuser

                 "Terrible let-me-in;role=manager"
                 :manager

                 (respond! <3>
                  (-> response
                      (assoc :ring.response/status 401)
                      (assoc-in
                       [:ring.response/headers "www-authenticate"]
                       "Terrible"))))]

        (if (get-in resource
              [:roles role (:ring.request/method request)]) <4>
          (assoc ctx :role role) <5>
          (respond! (assoc response :ring.response/status 403)) <6>
          )))}}
----
<1> some custom data in the resource map we'll use later
<2> authenticate the request
<3> respond with a 401 if tell the user-agent to send credentials
<4> is the method allowed for this role?
<5> yes? then the request can proceed, return the ctx (adding the role)
<6> no? then the request is forbidden, return a 403
====


[[representation]]
==== `representation`

The representation meta-data of the current representation of the target
resource, as a map.

If this is present, then it will determine the response for a GET request.

WARNING: Don't forget to add this (or `select-representation` below). If this
isn't provided, then you'll get a 404 response for a GET. This might be
surprising!

==== `select-representation`

A function that takes a context argument and returns a map corresponding to the
selected representation's metadata.

The representation should be chosen based on the request (the `:request` entry
of the context) and the response (the `:response` entry of the context). Usually
this means looking up the `:ring.response/status` of the response, since the
desirable content type often depends on the status of the response. For
instance, the representation of an error might only be available in English,
regardless of the language preferences of the user agent.

Proactive content negotiation may be employed to determine the representation.

// TODO: Discuss reactive content negotiation here

==== `post!`

A function that takes the context as an argument.

The function is called on a POST request.

The `post!` function is responsible for any data processing associated with a
POST. If a new resource is created, it should respond with a 201 status and a
`Location` header containing the URL of the new resource. A convenience function
is available (`juxt.spin.alpha/resource-created!`) which does this.

To respond, it should call the `respond!` function provided in the context
argument with the (Ring 2.0) response as an argument.

See link:https://tools.ietf.org/html/rfc7231.html#section-4.3.3[Section 4.3.3 of
RFC 7231] for further details.

==== `put!`

A function that takes the context as an argument.

The function is called on a PUT request.

Generally speaking, the `put!` function is responsible for replacing the state
of the target resource with the representation enclosed in the request message
payload.

To respond, it should call the `respond!` function provided in the context
argument with the (Ring 2.0) response as an argument.

See
link:https://tools.ietf.org/html/rfc7231.html#section-4.3.4[Section 4.3.4 of RFC
7231] for further details.

==== `delete!`

A function that takes the context as an argument.

The function is called on a DELETE request.

To respond, it should call the `respond!` function provided in the context
argument with the (Ring 2.0) response as an argument.

See
link:https://tools.ietf.org/html/rfc7231.html#section-4.3.5[Section 4.3.5 of RFC
7231] for further details.


=== Request map entries

==== `request` (provided)

A map describing a Ring request, see
https://github.com/ring-clojure/ring/blob/2.0/SPEC-2.md

==== `respond!` (provided)

A callback function that is used to return a Ring response, which is map. See
https://github.com/ring-clojure/ring/blob/2.0/SPEC-2.md for full details.

==== `raise!` (provided)

A callback function that is used to raise any errors. See
https://github.com/ring-clojure/ring/blob/2.0/SPEC-2.md for full details.

== Relationship to yada

JUXT has published another older library, https://github.com/juxt/yada[_yada_],
which shares similar goals to this project.

Spin is hoped to be an official successor to https://github.com/juxt/yada.

=== Async

Both Spin and _yada_ support asynchronous servers. In the case of _yada_, it is bound to https://github.com/aleph-io/manifold[manifold] which is in turn bound to https://github.com/aleph-io/aleph/[aleph] and onto Netty.

Spin is based the asynchronous standard defined in Ring 1.6 which was not yet
established when _yada_ was designed.

== But why is it called Spin?

The name 'spin' is a deliberate pun on the word 'web'.

== License

The MIT License (MIT)

Copyright © 2020 JUXT LTD.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
