= Spin

_Far more web_ for _much less code_.

Since the earliest web servers, dynamic behaviour in web servers has been built
on the https://www.w3.org/CGI/[CGI: Common Gateway Interface]. CGI itself has
been consigned to history but the model of web development that it inspired is
still by far the dominant model used by developers of websites and web APIs.

In CGI, a web-server captures information about a web request (such as the
request method, path, remote address, query-string, etc.) and calls a sends it
to an external program or script, or in-process function, that generates the
response on behalf of the web server.

As web-servers have evolved, virtually every web library and framework has
inherited this minimalist design: from Java's 'servlets' and Ruby's
https://www.rubyguides.com/2018/09/rack-middleware/[Rack] and PHP to Node.js
Express, Erlang's https://www.phoenixframework.org/[Phoenix], Clojure's
https://github.com/ring-clojure/ring[Ring] and hundreds more.

== Problem Statement

The problem at the heart of CGI, and everything based on it, is that it is an
interface based on a web _request_ rather than a web _resource_. It was designed
to attach basic scripts to web servers, not to build the web itself.

The web is built on the HTTP protocol, which governs how browsers, web-servers,
proxies and other participants communicate. What does HTTP provide? It's right
there in just the second paragraph:

[quote,RFC 7231 - Section 1]
____
HTTP provides a uniform interface for interacting with a _resource_
____

The problem with CGI-based web libraries is that CGI is too low-level. It asks
too much of developers who have to recreate this 'resource' abstraction in every
handler they write. Of course this results in HTTP services that are half-baked,
half-implemented and non-comformant with HTTP. This makes the web poorer: *less
inter-operable*, *less dynamic* and *more expensive to create and maintain*.

== Proposed Solution

Spin defines a new _resource-oriented_ interface to replace CGI.

Spin also provides an adapter that converts the CGI-based request-oriented
interface of Java/Clojure web servers to this new resource-oriented interface.

You provide code that satisfies Spin's Clojure protocols. In exchange, you get a
runtime that fully conforms with HTTP.

Spin is written in Clojure because it provides a very fast design iteration
cycle. But it is hoped that once Spin's design stabilises it can be copied by
others, just as CGI was.

== But why is it called Spin?

The name 'spin' is a deliberate pun on the word 'web'.

== Relevant Standards

Spin implements RFCs 7231-7235 as faithfully as possible.

== Status

Spin is still under active development and is ALPHA status, meaning that the API
should be considered unstable and likely to change.

It is planned that Spin will be agnostic as to whether you are using Ring's sync
(1-arity) of async (3-arity) forms and will support both.

== Relationship to other Clojure libraries

Spin is hoped to be an official successor to https://github.com/juxt/yada.

Spin is independent of routing and treats URIs as opaque. This lets you 'bring
your own router', and so can be used with Compojure, bidi, Reitit and other
Clojure routing libraries.

== Reference

You create a Ring handler with `juxt.spin.alpha.ctx/handler` that takes a single map argument, called the context.

[source,clojure]
----
(def handler (juxt.spin.alpha.ctx/handler {…}))

(handler req) => response
----

This map contains the following entries, which are namespaced in the
`juxt.spin.alpha` namespace (aliased below to `spin`).

=== Initial context entries

The initial context should contain the resource description as a map, or a
function for locating one from the request.

Whether you should choose a resource or a resource locator depends on your
application. If you are using a router (Compojure, bidi, reitit, etc.), you
might route directly to the target resource. This also makes sense for simple
demos.

However, the benefit of using `locate-resource!` is that you can have one initial
context defined with all your application-wide (or context-wide) configuration
and policies.

==== `locate-resource!` (optional)

A function that takes a request context as an argument, and returns a map
describing the target resource.

A resource is always deemed to exist. Return an empty map (`{}`) if there are no
current representations for the resource.

A `locate-resource!` function can use the `respond!` entry in the request context
argument in order to respond directly. This effectively returns a nil, which indicates a response is made directly. Therefore, it is important never to return nil from `locate-resource!`.

If `locate-resource!` is not provided in the initial context, the resource
defaults to an empty map.

==== `resource` (optional)

A map describing the target resource.

If this is provided, then it is used regardless of whether
`locate-resource!` is provided also. If this is not specified up-front, it
is provided in the context once it is located. See `locate-resource!`.

=== Resource entries

==== good-request! (optional)

A function that takes a context argument and returns truthy if the request is
valid. The resource can be found in the `:resource` entry of the context.

If the request is malformed or invalid in some way, the function MUST respond
directly using the function in the `:respond!` entry of the context, and for the
response, SHOULD use the value in the `:response` entry of the context (although
it is free to modify it as necessary).

==== select-representation (optional)

A function that takes a context argument and returns a map corresponding to the
selected representation's metadata.

The representation should be chosen based on the `request` and `status` entries
of the context argument. Proactive content negotiation may be employed to
determine the representation.

==== representation (optional)

The representation meta-data, as a constant. If this is present, then it is
chosen when the status is 200 (in the case of a GET).p

==== `post!` (optional)

A function that takes the context as an argument. The function should call the
`respond!` function provided in the context to return a response.

A `post!` function is responsible for any data processing. If a new resource is
created, it should respond with a 201 status and a `Location` header containing
the URL of the new resource. A convenience function is available
(`juxt.spin.alpha.ctx/resource-created!`) which does this. See
link:https://tools.ietf.org/html/rfc7231.html#section-4.3.3[Section 4.3.3 of RFC
7231] for further details.

=== Request context entries

==== `request` (provided)

A map describing a Ring request, see
https://github.com/ring-clojure/ring/blob/2.0/SPEC-2.md

==== `respond!` (provided)

A callback function that is used to return a Ring response, which is map. See
https://github.com/ring-clojure/ring/blob/2.0/SPEC-2.md for full details.

==== `raise!` (provided)

A callback function that is used to raise any errors. See
https://github.com/ring-clojure/ring/blob/2.0/SPEC-2.md for full details.

== License

The MIT License (MIT)

Copyright © 2020 JUXT LTD.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
